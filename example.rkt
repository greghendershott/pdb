#lang racket/base

(require racket/runtime-path
         rackunit
         "db.rkt"
         "analyze.rkt")

(define-runtime-path define.rkt "example/define.rkt")
(define define.rkt/str (path->string define.rkt))
(define-runtime-path require.rkt "example/require.rkt")
(define require.rkt/str (path->string require.rkt))

(define (tests)
    ;; Re-analyze example/define.rkt and example/require.rkt.
  (forget-digest (build-path define.rkt))
  (forget-digest (build-path require.rkt))
  (analyze-path (build-path require.rkt))
  ;; Test that various uses in example/require.rkt point to the
  ;; correct definition location in example/define.rkt.
  (check-equal? (use-pos->def require.rkt 42)
                (vector define.rkt/str "()" "plain" 88 93)
                "plain")
  (check-equal? (use-pos->def require.rkt 42)
                (use-pos->def/transitive require.rkt 42)
                "transitive def of non-contract-wrapped is the same")
  (check-equal? (use-pos->def require.rkt 48)
                (vector define.rkt/str "()" "plain" 88 93)
                "renamed")
  (check-equal? (use-pos->def require.rkt 56)
                (vector define.rkt/str "()" "provide/contract-id-contracted1.1" 207 218)
                "contracted1")
  (check-equal? (use-pos->def/transitive require.rkt 56)
                (vector define.rkt/str "()" "contracted1" 165 176)
                "contracted1 transitive")
  (check-equal? (use-pos->def require.rkt 68)
                (vector define.rkt/str "()" "provide/contract-id-contracted2.1" 283 294)
                "contracted2")
  (check-equal? (use-pos->def/transitive require.rkt 68)
                (vector define.rkt/str "()" "contracted2" 246 257)
                "contracted2 transitive")
  (check-equal? (use-pos->def require.rkt 80)
                (vector define.rkt/str "()" "provide/contract-id-contracted/renamed.1" 363 366)
                "contracted/renamed => c/r")
  (check-equal? (use-pos->def/transitive require.rkt 80)
                (vector define.rkt/str "()" "c/r" 322 325)
                "contracted/renamed => c/r [transitive]")
  (check-equal? (use-pos->def require.rkt 99)
                (vector define.rkt/str "()" "plain-by-macro" 515 529)
                "plain-by-macro")
  (check-equal? (use-pos->def require.rkt 114)
                (vector define.rkt/str "()" "provide/contract-id-contracted-by-macro.1" 684 703)
                "contracted-by-macro")
  (check-equal? (use-pos->def require.rkt 134)
                (vector define.rkt/str "(sub)" "sub" 958 961)
                "sub")
  (check-equal? (use-pos->def require.rkt 138)
                (vector define.rkt/str "(sub)" "sub" 958 961)
                "sub/renamed")
  (check-equal? (use-pos->def require.rkt 150)
                (vector define.rkt/str "()" "foo" 1179 1182)
                "foo")
  (check-equal? (use-pos->def require.rkt 154)
                (vector define.rkt/str "()" "a-number" 1225 1233)
                "a-number")
  (check-equal? (use-pos->def require.rkt 163)
                (vector define.rkt/str "()" "a-parameter" 1265 1276)
                "a-parameter")
  (check-equal? (use-pos->def require.rkt 175)
                (vector define.rkt/str "()" "provide/contract-id-from-m.1" 1421 1427)
                "from-m")
  (check-equal? (use-pos->def require.rkt 182)
                (vector define.rkt/str "()" "d/c" 1456 1459)
                "d/c")
  (check-equal? (use-pos->def require.rkt 186)
                (vector define.rkt/str "()" "d/c" 1456 1459)
                "renamed-d/c")

  (check-equal? (get-uses define.rkt '() 'c/r)
                (list
                 (vector define.rkt/str "c/r" 363 366))
                "get-uses")
  (check-equal? (get-uses/transitive define.rkt '() 'c/r)
                (list
                 (vector define.rkt/str "c/r" 363 366)
                 (vector require.rkt/str "provide/contract-id-contracted/renamed.1" 80 98)
                 (vector require.rkt/str "provide/contract-id-contracted/renamed.1" 405 408)
                 (vector require.rkt/str "provide/contract-id-contracted/renamed.1" 290 312))
                "get-uses/transitive"))

(module+ test
  (open 'memory analyze-code)
  (create-tables)
  (tests))

(module+ on-disk-example
  (define-runtime-path db-path "locs.sqlite")
  (create-database db-path)
  (open db-path analyze-code)
  ;; Doing this means analyze-path will queue up more files to
  ;; analyze, transitively, until reaching a fixed point.
  (start-analyze-more-files-thread)
  (tests)

  ;; Re-analyze another file (and watch the `definitions` logger topic)
  (define-runtime-path db.rkt "db.rkt")
  (forget-digest (build-path db.rkt))
  (analyze-path (build-path db.rkt)))
